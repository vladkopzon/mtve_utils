#!/usr/bin/env python3
#Author: Vlad Kopzon

import sys
import os
import hjson
import re
import logging
import filecmp
import shutil
from pathlib import Path


class indent:
    def __init__(self, value=0, indent=4, indent_char=' '):
        self.value       = value
        self.indent      = indent
        self.indent_char = indent_char
        
    def increment(self, step=1):
        self.value += self.indent * step

    def decrement(self, step=1):
        self.value -= self.indent * step
        
    def __str__(self):
        return self.indent_char * self.value


class header_generator(object):

    V_SUFFIX = '_MTV_STUB_REGS'
    
    def __init__(self, template=None):
        self.template = os.path.abspath(template)
        self.VARS = {}
        self.indent = indent()
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)

        
    def load_config(self):
        try:
            # Open the Hjson file and load its contents
            with open(self.template, 'r') as hjson_file:
                cfg = hjson.load(hjson_file)
                self.VARS  = cfg["mtv"]
                self.STUBS = cfg["mtv_stub"]
                self.logger.debug(self.VARS)
        except FileNotFoundError:
            self.logger.critical(f"The file '{self.template}' was not found.")
            return(-1)
        except hjson.decoder.HjsonDecodeError as e:
            print(f"Error decoding Hjson: {e}")
            return(-1)
        return (1)

    def parse_num(self, s=None, frmt=None):
        if frmt == 'vh':
            if isinstance(s, str):
                s = s.replace("0x", "'h")
            else:
                s = "'d" + str(s)
        elif isinstance(s, str):       # python
            if s.startswith('`'): # verilog define
                s = s.replace("`","")
                s = self.VARS['VALUES'][s]
            elif not s.startswith('0x'): # real string
                s = f'"{s}"'
        return(s)

    def write_header_file(self, output=sys.stdout, formatter='py', stubdir=None):
        comment = '//'
        separator = '/' * 80
        if formatter == 'py' :
            comment = '#'
            separator = '#' * 80

        ################################################################################
        # VALUES:
        print(separator, file=output)
        print(f'{comment} Autogenerated headers for values:', file=output)
        print(separator, file=output)
        if formatter=='py':
            print('from enum import Enum, auto', "\n", file=output)
            print('class MTVE_GLOBALS(object):', file=output)
            self.indent.increment()
        for var, value in self.VARS['VALUES'].items():
            pvalue = self.parse_num(s=value, frmt=formatter)
            if value == '___SET_BY__ENV___':
                evalue = f"{os.environ.get(var, 'ERROR: UNDEFINED_IN_TIME_OF_GENERATION')}"
                pvalue = f'"{evalue}"'
            if formatter == 'vh':
                print(f'`define {var} {pvalue}', file=output)
            elif formatter == 'py':
                print(f'    {var} = {pvalue}', file=output)
            elif formatter == 'h':
                print(f'#define {var} {pvalue}', file=output)

        ################################################################################
        # RANGES:
        print('', file=output)
        print(separator, file=output)
        print(f'{comment} Autogenerated headers for ranges:', file=output)
        print(separator, file=output)
        for var, value in self.VARS['RANGES'].items():
            if formatter == 'vh':
                print(f'`define {var} {value[0]}:{value[1]}', file=output)
            elif formatter == 'py':
                print(f'    {var}_MSB = {value[0]}', file=output)
                print(f'    {var}_LSB = {value[1]}', file=output)
                print(f'    {var}_WIDTH = {value[0]-value[1]+1}', file=output)
            elif formatter == 'h':
                print(f'#define {var}_MSB  {value[0]}', file=output)
                print(f'#define {var}_LSB  {value[1]}', file=output)

        ################################################################################
        # ENUMS:
        print('', file=output)
        print(separator, file=output)
        print(f'{comment} Autogenerated headers for enums:', file=output)
        print(separator, file=output)
        for var, value in self.VARS['ENUMS'].items():
            evalue = ','.join(value)
            if formatter == 'vh':
                print(f'typedef enum {{{evalue}}} {var};', file=output)
            elif formatter == 'py':
                enum_idx = 0
                print(f'    class {var}(Enum):', file=output)
                for enum in value:
                    print(f'        {enum} = {enum_idx}', file=output)
                    enum_idx += 1
            elif formatter == 'h':
                print(f'enum {var} {{{evalue}}};', file=output)

        ################################################################################
        # STUBS:
        if not self.STUBS:
            return 1
        
        print('', file=output)
        print(separator, file=output)
        print(f'{comment} Autogenerated headers for stubs:', file=output)
        print(separator, file=output)
        if formatter == 'vh':
            xmr_fname  = Path(stubdir) / ('dut_stabs_xmr.sv')
            xmr = open(xmr_fname, "w")
            ored_read_data_list = []
            vreg_reset_block  = []
            vreg_wr_assignment_block  = []
            vreg_rd_assignment_block  = []
            vreg_pinlist = []
        elif formatter == 'py':
            print(f'{self.indent}STUBS = {{', file=output)
            self.indent.increment()
            
        for stub, item in self.STUBS.items():
            stub_reg_address = item['base_addr']
            if formatter == 'py':
                print(f'{self.indent}"{stub}" : {{', file=output)
                self.indent.increment()
            elif formatter == 'vh':
                vreg_reset_block  = []
                vreg_wr_assignment_block  = []
                vreg_rd_assignment_block  = []
                vreg_pinlist = []
                stub_mname = stub + self.V_SUFFIX
                print(f'''
assign {item["path"]}.{stub_mname}.stub_write_en   = `DUT_XTOR.reg_mem[`MTV_DUT_STUB_CMD_IDX][`MTV_DUT_STUB_CMD_WE_RANGE];
assign {item["path"]}.{stub_mname}.stub_addr       = `DUT_XTOR.reg_mem[`MTV_DUT_STUB_CMD_IDX][`MTV_DUT_STUB_CMD_ADDR_RANGE];
assign {item["path"]}.{stub_mname}.stub_write_data = `DUT_XTOR.reg_mem[`MTV_DUT_STUB_WDATA_IDX];
                ''', file=xmr)
                ored_read_data_list.append(f'{item["path"]}.{stub_mname}.stub_read_data')
            for reg, params in item['regs'].items():
                width = params["width"]
                value = self.parse_num(s=params["reset"], frmt=formatter)
                if formatter == 'py':
                    print(f'''{self.indent}"{reg}" : {{
                "address" : {stub_reg_address},
                "width"   : {width},
                "value"   : {value}
            }},''', file=output)
                elif formatter == 'vh':
                    vreg_pinlist.append(f'output reg [{width-1} : 0] {reg}')
                    vreg_reset_block.append(f"{reg} <= {value};")
                    pad_width = 32 - width
                    if pad_width:
                        pad_string = f"{pad_width}'b0, "
                    else:
                        pad_string = ''
                    vreg_wr_assignment_block.append(f"{stub_reg_address} : {reg} <= stub_write_data[{width-1}:0];")
                    vreg_rd_assignment_block.append(f"{stub_reg_address} : stub_read_data[{width-1}:0] <= {{{pad_string}{reg}}};")
                stub_reg_address += 1
            self.indent.decrement()
            if formatter == 'py':
                print(f'{self.indent}}},', file=output)
            if formatter == 'vh':
                vregs_name = Path(stubdir) / (stub_mname + '.sv')
                vregs = open(vregs_name, "w")
                pinlist             = ',\n    '.join(f'{item}' for item in vreg_pinlist)
                reset_block         = '\n      '.join(f'{item}' for item in vreg_reset_block)
                rd_assignment_block = '\n          '.join(f'{item}' for item in vreg_rd_assignment_block)
                wr_assignment_block = '\n          '.join(f'{item}' for item in vreg_wr_assignment_block)
                print(f"""/* AUTOGENERATED MODULE - DO NOT EDIT DIRECTLY! */

module {stub}{self.V_SUFFIX} (
    input stub_clk,
    input stub_rstn,
    {pinlist}
);

 /* wires/regs will be connected to DUT xTOR by XMR ______ */
  wire                               stub_write_en;              
  wire [`MTVE_STUB_ADDR_WIDTH-1 : 0] stub_addr;
  wire [`MTVE_STUB_DATA_WIDTH-1 : 0] stub_write_data;

  reg  [`MTVE_STUB_DATA_WIDTH-1 : 0] stub_read_data,
 /*________________________________________________________*/

  always @(posedge stub_clk or negedge stub_rstn) begin
    if (~stub_rstn) begin
      {reset_block}
    end
    else begin
      if (stub_write_en) begin
        case (stub_addr)
          {wr_assignment_block}
        endcase
      end
      else begin
        case (stub_addr)
          {rd_assignment_block}
          default: stub_read_data <= 'd0;
        endcase
      end
    end
  end
endmodule
""", file=vregs)
                vregs.close()
                print(f"STUB_REGS for {stub} successfully created")

        self.indent.decrement()
        if formatter == 'py':
            print(f'{self.indent}}},', file=output)
        elif formatter == 'vh':
            ored_read_data = ('\n'+ ' '*54 + '| ').join(f'{item}' for item in ored_read_data_list)
            print(f'wire [`MTVE_STUB_DATA_WIDTH-1 : 0] stub_read_response = {ored_read_data};', file=xmr)
            xmr.close()

        return(1)


################################################################################    

if __name__ == "__main__":
    import argparse

    logging.basicConfig(format='%(levelname)s - %(module)s.%(funcName)s - %(message)s')

    parser = argparse.ArgumentParser()    
    parser.add_argument('-template', type=str, required=True,
                        help='Specify template hjson file')
    parser.add_argument('-output', type=str, required=True,
                        help="Output file name and format by extention: [.py|.vh|.h]. In absense of ext all supported views will be generated")
    parser.add_argument('-stubdir', type=str, required=True,
                        help="Output diretory name for all stubs to be generated into.")
    parser.add_argument('-dev' ,  action='store_true',
                        help='For script development only')

    args = parser.parse_args()

    backup_file = args.stubdir + '/crun.cfg.last'
    if os.path.exists(backup_file):
        if filecmp.cmp(args.template, backup_file):
            #nothing to make
            print('    Nothing to build.')
            exit(0)

    V = header_generator(template=args.template)
    if not V.load_config():
        exit(0)

    fname, fextension = os.path.splitext(args.output)
    fextension = fextension[1:]
    if fextension=="":          # all views to be generated
        all_formats = ['py', 'vh', 'h']
    else:
        all_formats = [fextension]

    for frmt in all_formats:
        try:
            with open(fname+'.'+frmt, "w") as f:
                status = V.write_header_file(output=f, formatter=frmt, stubdir=args.stubdir)
                f.close()
                if status:
                    print(f"HEADER output file successfully created [.{frmt}]")
                else:
                    print("No output generated. See previous errors!")
        except FileNotFoundError:
            print(f"The file '{args.output}' was not found.")
            print("No output generated. See previous errors!")
            exit(0)

    #make backup for next run
    shutil.copyfile(args.template, backup_file)

   
